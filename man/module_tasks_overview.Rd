% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/module_tasks_overview.R
\name{tasks_overview_server}
\alias{tasks_overview_server}
\alias{tasks_overview_UI}
\title{Module to visualize all the created tasks.}
\usage{
tasks_overview_server(
  input,
  output,
  session,
  dir_path,
  allowed_run_info_cols = c("date_creation", "date_start", "date_end", "priority",
    "status"),
  allow_descr = TRUE,
  allowed_function_cols = c("path", "name"),
  allow_args = TRUE,
  allowed_status = c("waiting", "running", "finished", "error"),
  allow_log_btn = TRUE,
  allow_rm_task = TRUE,
  update_mode = c("reactive", "button"),
  intervalMillis = 1000,
  table_fun = function(x) x,
  return_value = c("selected_task", "tasks_table"),
  ...
)

tasks_overview_UI(
  id,
  labels = list(btn = "Display/update the tasks", empty_global =
    "Empty table of global features.", empty_individual =
    "Empty table of individual features.", error_dir_access =
    "Cannot access given directory.", logs = "Show logs", remove_task =
    "Remove this task ?")
)
}
\arguments{
\item{input}{shiny input}

\item{output}{shiny input}

\item{session}{shiny input}

\item{dir_path}{\code{character}. Where to find the tasks directorys.}

\item{allowed_run_info_cols}{\code{character} (c("date_creation", "date_start", "date_end", "priority", "status")). Run info elements to be kept.}

\item{allow_descr}{\code{boolean or character} (TRUE). Either a boolean specifying whether or not to keep descr elements, or column names.}

\item{allowed_function_cols}{\code{character} (c("names", "path")). Function elements to be kept.}

\item{allow_args}{\code{boolean or character} (TRUE). Either a boolean specifying whether or not to keep args elements, or column names.}

\item{allowed_status}{\code{character} (c("waiting", "running", "finished", "error")). Vector of allowed status.}

\item{allow_log_btn}{\code{boolean} (TRUE). Whether or not to display a button to show log in modal.}

\item{allow_rm_task}{\code{boolean} (TRUE). Whether or not to display a button to show log in modal.}

\item{update_mode}{\code{character} : "reactive" (default) use \code{shiny::reactivePoll} to see if tasks info have changed.
"button" add and use a \code{shiny::actionButton} to update task info table.}

\item{intervalMillis}{\code{integer}. In case of "reactive" update_mode, time betweens calls}

\item{table_fun}{\code{function} (function(x) x). Function to be applied on the summary table, making it easy to customize it. First arg must be the summmary table.}

\item{return_value}{\code{character} : "selected_task" (default) return the selected task using \code{tasks_overview_UI},
else "tasks_table"can be used to get all tasks information and define a custom UI.}

\item{...}{\code{}. Additional args to be given to the table_fun function.}

\item{id}{\code{character}. shiny id to allow multiple instanciation.}

\item{labels}{\code{list} UI labels}
}
\value{
if \code{return_value = "selected_task"}, the status of the selected line (one run) of the summary
table and the path to the directory in which its output is stored. if \code{return_value = "tasks_table"},
all tasks information table
}
\description{
Module to visualize all the created tasks.
}
\examples{

\donttest{


if(interactive()){

require(shiny)

# create temporary directory for conf
dir_conf <- paste0(tempdir(), "/conf", round(runif(n = 1, max = 10000)))
dir.create(dir_conf, recursive = TRUE)

# ex fun
fun_path = system.file("ex_fun/sb_fun_ex.R", package = "shinybatch")
fun_name = "sb_fun_ex"

# create 2 confs
conf_1 <- configure_task(dir_path = dir_conf,
                         conf_descr = list(title = "my_title_1",
                                           description = "my_descr_1"),
                         fun_path = fun_path,
                         fun_name = fun_name,,
                         fun_args = list(x = 1,
                                         y = 0:4,
                                         z = iris),
                         priority = 1)
conf_2 <- configure_task(dir_path = dir_conf,
                         conf_descr = list(title = "my_title_2",
                                           description = "my_descr_2"),
                         fun_path = fun_path,
                         fun_name = fun_name,
                         fun_args = list(x = 1,
                                         y = 0:4,
                                         z = iris),
                         priority = 2)

run_task(paste0(conf_2$dir, "conf.yml"))

# with package ui
ui <- shiny::fluidPage(
  tasks_overview_UI("my_id_1"),
  hr(),
  verbatimTextOutput("info")
)

server <- function(input, output, session) {
  selected_task <- callModule(tasks_overview_server, "my_id_1",
             dir_path = dir_conf,
             allowed_status = c("waiting", "running", "finished", "error"),
             allowed_run_info_cols = NULL,
             allowed_function_cols = "",
             allow_descr = TRUE,
             allow_args = TRUE,
             table_fun = function(x, y) x[, new_col := y],
             y = "created using arg. 'table_fun'")

  output$info <- renderPrint({
    selected_task()
  })
}
shiny::shinyApp(ui = ui, server = server)

# using custom ui
ui <- shiny::fluidPage(
  verbatimTextOutput("info")
  # and so define what you want !
)

server <- function(input, output, session) {
  all_tasks_info <- callModule(tasks_overview_server, "my_id_1",
             dir_path = dir_conf,
             return_value = "tasks_table"
  )

  output$info <- renderPrint({
    all_tasks_info()
  })
}
shiny::shinyApp(ui = ui, server = server)

}
}

}
\seealso{
\code{\link[shinybatch]{configure_task_server}}
}
